# -*- coding: utf-8 -*-
"""Despliegue de resultados modelo .ipynb
Automatically generated by Colab.
Original file is located at
    https://colab.research.google.com/drive/1ayl1ITQM6zQi7OBrLZx8Bt9GpUFYq4Np?usp=sharing
#Despliegue de resultados del modelo de Machine Learning
**Nota:** Para que corra el modelo hay que agregar el dataset y el modelo que trabajó cada grupo de manera individual
El **primer paso** es guardar el modelo y la lista de las columnas entrenadas en una variable
"""
#Instalar las librerías necesarias para el despliegue web
#pip install numpy, pandas, scikit-learn,joblib, flask-ngrok


# Librerias para manipulacion de Data y Gráficas
import numpy as np
import matplotlib.pyplot as plt 
import pandas as pd
import seaborn as sns

#Preparación de datos y configuración de pipeline para Machine Learning con scikit-learn
from sklearn.pipeline import make_pipeline
from sklearn.model_selection import train_test_split
from sklearn.model_selection import validation_curve
from sklearn.model_selection import cross_val_score
from sklearn.compose import ColumnTransformer, make_column_transformer
from sklearn.preprocessing import StandardScaler, OneHotEncoder, LabelEncoder

#Modelos
from sklearn.linear_model import LinearRegression
from sklearn.linear_model import LogisticRegression
from flask import Flask, request, render_template

app = Flask(__name__)

X_train = pd.read_csv('X_train.csv')
y_train = pd.read_csv('y_train.csv') 

# Suponiendo que se trabajó con REGRESIÓN LOGÍSTICA se guarda el modelo en la variable 'model' y la lista de las columnas entrenadas en la variable 'columns_train
model = LogisticRegression(max_iter = 1000)
#colummns_train = X_train.columns.tolist()
model.fit(X_train, y_train)  # Entrena el modelo con los datos de entrenamiento

"""El **segundo paso** consiste en  convertir el modelo y las columans en un archivo pickle (.pkl) y crear una ruta donde se van a encontrar los archivos convertidos.
Para tener todo en la misma carpeta, se creó una carpeta en drive 'futbol_app' (se puede perosnalizar según el proyecto), donde se van a guardar los archivos pickle.

"""
import joblib

#Rutas de los archivos pickle
#ruta_modelo = 'modelo.pkl'
ruta_columnas = 'columnas_modelo.pkl'
#Se importa la librería que permita convertir los objetos en archivos pickle

#Se convierten los objetos en archivos pickle
#joblib.dump(model, ruta_modelo)
joblib.dump(X_train.columns.tolist(), ruta_columnas)

"""El **tercer paso** consiste  en crear una carpeta (dentro de la carpeta 'futbol_app') llamada 'template' y guardar dentro de ella, el archivo 'formulario.html'(frontend)

El **cuarto paso** consiste  en realizar el backend del despliegue web que se realizará
"""
#Cargar el modelo en el backend
#modelo = joblib.load(ruta_modelo)
columnas = joblib.load(ruta_columnas)

#Importar las funciones a partir del flask qu enos va a permitir crear un API

@app.route('/')
def home():
    return render_template('formulario.html')

@app.route('/predict', methods=['POST'])
def predict():
    # Obtener datos del formulario
    home_team = request.form['HOME_TEAM']
    visitor_team = request.form['VISITOR_TEAM']
    pts_home = int(request.form['PTS_HOME'])
    prob_tiros = float(request.form['FG_PCT_home'])
    

    # Crear un DataFrame vacío con las columnas esperadas
    entrada = pd.DataFrame([[0] * len(columnas)], columns=columnas)

    # Asignar valores a las columnas correspondientes
    col_home = f'HOME_TEAM_{home_team}'
    col_away = f'VISITOR_TEAM_{visitor_team}'

    if col_home in columnas:
        entrada[col_home] = 1
    if col_away in columnas:
        entrada[col_away] = 1
    if 'PTS_HOME' in columnas:
        entrada['PTS_HOME'] = pts_home
    if 'FG_PCT_home' in columnas:
        entrada['FG_PCT_home'] = prob_tiros

    resultado = model.predict(entrada)[0]
    salida = {0: 'Pierde Local', 1: 'Gana Local'}

    return render_template('formulario.html', prediction=salida[resultado])

if __name__ == '__main__':
    app.run(debug=True)

